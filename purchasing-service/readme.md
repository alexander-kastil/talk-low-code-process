# Purchasing Service

This microservice exposes a small purchasing API used to request price offers from known suppliers and to list supplier information. The README below focuses on what the service does and how the code behaves at runtime (endpoints, request/response shapes and business logic), not on installation or deployment.

### High-level purpose

The service simulates supplier offer generation for product purchase requests. Given a supplier id and a list of requested products (name + quantity), the service returns an offer containing per-product offered quantities, offered prices, availability flags, delivery durations and a transportation cost.

The implementation is deterministic in structure but intentionally uses a randomizer component to vary offered prices, availability and delivery durations so callers can exercise realistic offer scenarios.

### Primary endpoints

- `POST /api/purchasing/offer` — generate an offer for a supplier

  - Input: `OfferRequest` (see models below)
  - Output: `OfferResponse` containing supplier id, transportation cost, generation timestamp and a list of `OfferResponseDetail` entries
  - Validation: request payload must be present, must include at least one product, and the supplier id must exist; unsupported product names return 400

- `GET /api/suppliers` — return all suppliers (read-only in-memory store)

- `GET /api/suppliers/{id}` — return supplier by id

- `GET /api/suppliers/by-name/{name}` — return supplier by company name

These endpoints are defined in `Controllers/PurchasingController.cs` and `Controllers/SuppliersController.cs`.

### Data models (shapes)

Key request/response shapes are defined in `Models/OfferModels.cs` and `Models/Suppliers.cs`.

- OfferRequest

  - `int SupplierId` (required)
  - `string RequestId` (required) — caller-provided correlation id
  - `List<OfferRequestDetail> OfferDetails` (required, at least 1)

- OfferRequestDetail

  - `string ProductName` (required)
  - `int RequestedAmount` (>= 1)

- OfferResponse

  - `Guid Id` — autogenerated identifier for the response
  - `string RequestId` — echoed back
  - `int SupplierId` — supplier identifier
  - `decimal TransportationCost` — fixed transport cost defined by the offer logic
  - `DateTimeOffset Timestamp` — UTC timestamp of offer generation
  - `IReadOnlyList<OfferResponseDetail> OfferDetails` — per-product results

- OfferResponseDetail (per product)
  - `string ProductName` — normalized name
  - `decimal BasePrice` — configured base price for the product
  - `decimal OfferedPrice` — final price offered (may be discount, base or markup)
  - `int RequestedAmount` — requested quantity
  - `int OfferedAmount` — quantity the supplier can deliver (may be 0)
  - `int DeliveryDurationDays` — estimated delivery time in days
  - `bool IsAvailable` — whether supplier can supply any quantity

Supplier model includes standard contact and address fields and is returned by the suppliers endpoints; the in-memory supplier list is in `Data/SupplierStore.cs`.

### Business logic and behavior

- The `OfferRandomizer` (`Services/OfferRandomizer.cs`) contains a small catalog of supported products and base prices (for example: "Butter Chicken": 6.50, "Wiener Schnitzel": 14.00, etc.). The product catalog and all randomizer tuning values are now driven by configuration (`OfferRandomizer` section in `appsettings.json` / `appsettings.Development.json`) and exposed via a strongly-typed `OfferRandomizerOptions` class.
- For each requested product the randomizer decides one of three pricing outcomes:
  - Return base price (configurable probability, default ~50%)
  - Apply a small discount (configurable probability and range, default ~20% probability; discount range 1%–10%)
  - Apply a markup (configurable probability and range, default ~30% probability; markup range 5%–25%)
- Prices are rounded to two decimal places.

## Tuning the OfferRandomizer

You can control and tune the behavior of the `OfferRandomizer` from configuration. The service binds the `OfferRandomizer` settings from the `OfferRandomizer` section in `appsettings.json` into the `OfferRandomizerOptions` POCO (see `Services/OfferRandomizerOptions.cs`). Changes to these values let you shape pricing outcomes, fulfillment behavior and delivery estimates without code changes.

Where to change

- Edit `src/purchasing-service/appsettings.json` (or environment-specific `appsettings.Development.json`) and update the `OfferRandomizer` section. The application reads the configured values on startup and the `OfferRandomizer` is registered from those values in `Program.cs`.

Key settings and what they control

- `TransportationCost` (decimal): fixed transportation cost added to every `OfferResponse`.

- `BasePrices` (map[string->decimal]): product catalog of supported product names and their base prices. Product names are matched case-insensitively. Add or update entries to reflect available items and their base prices.

- `Pricing` (object): controls the pricing decision probabilities and ranges.

  - `BaseProbability` (double, 0..1): probability the randomizer returns the base price unchanged.
  - `DiscountProbability` (double, 0..1): probability the randomizer applies a discount. If the random draw falls in this range the price is reduced by a percentage sampled between `DiscountMin` and `DiscountMax`.
  - `MarkupProbability` (double, 0..1): documented in options for clarity; the implementation treats markup as the fallback when the draw does not fall into base or discount ranges (effectively markup probability ≈ 1 - BaseProbability - DiscountProbability).
  - `DiscountMin` / `DiscountMax` (double): discount percentage bounds (0.01 is 1%, 0.10 is 10%).
  - `MarkupMin` / `MarkupMax` (double): markup percentage bounds used when the draw results in a markup.

- `Quantity` (object): controls quantity fulfillment behavior.

  - `FulfillProbability` (double, default ~0.8): probability the supplier fulfills the full requested amount.
  - `ReducedProbability` (double): probability the supplier returns a reduced amount (a percentage between `ReducedMin` and `ReducedMax` of the requested amount).
  - `UnavailableProbability` (double): probability the product is unavailable (`OfferedAmount == 0`).
  - `ReducedMin` / `ReducedMax` (double): bounds for reduction percent when the supplier partially fulfills the request.

- `Delivery` (object): controls delivery timing.
  - `CommonProbability` (double): probability of selecting one of the two common delivery durations specified in `CommonDays` (e.g., 2 or 3 days).
  - `CommonDays` (int[]): two common delivery durations used with `CommonProbability`.
  - `AdditionalDaysBase` (int) and `AdditionalDaysRange` (int): when the draw falls outside the common case, the delivery duration is `AdditionalDaysBase + random(0..AdditionalDaysRange-1)`.

Practical tuning tips

- To make discounts more common: increase `DiscountProbability` and decrease `BaseProbability` accordingly. Ensure probabilities remain in a sensible range; markup is implicitly the remaining probability.
- To make suppliers less reliable: lower `FulfillProbability` and increase `ReducedProbability` / `UnavailableProbability`.
- To increase delivery variability: lower `CommonProbability` and increase `AdditionalDaysRange`.
- Keep numeric ranges sensible (percentages between 0.0 and 1.0, integer day values >= 0).

Example snippet (from `appsettings.json`)

```json
"OfferRandomizer": {
  "TransportationCost": 30.00,
  "Pricing": {
    "BaseProbability": 0.5,
    "DiscountProbability": 0.2,
    "MarkupProbability": 0.3,
    "DiscountMin": 0.01,
    "DiscountMax": 0.10,
    "MarkupMin": 0.05,
    "MarkupMax": 0.25
  },
  "Quantity": {
    "FulfillProbability": 0.8,
    "ReducedProbability": 0.1,
    "UnavailableProbability": 0.1,
    "ReducedMin": 0.01,
    "ReducedMax": 0.30
  },
  "Delivery": {
    "CommonProbability": 0.7,
    "CommonDays": [2,3],
    "AdditionalDaysBase": 4,
    "AdditionalDaysRange": 4
  },
  "BasePrices": {
    "Butter Chicken": 6.50,
    "Blini with Salmon": 9.50,
    "Wiener Schnitzel": 14.00
  }
}
```

How changes take effect

- The service reads configuration at startup and registers a singleton `OfferRandomizer` with the configured `OfferRandomizerOptions` bound from `OfferRandomizer` section (see `Program.cs`). After editing `appsettings.json` you must restart the service for changes to take effect. In development you can use dotnet watch or your IDE's run/debug to pick up the new values after restart.

When to change code vs config

- Small catalog updates (new product prices), probability tweaks, and delivery windows are all best done in configuration.
- If you need dynamic runtime reconfiguration (no restart), consider adding an `IOptionsMonitor<OfferRandomizerOptions>`-backed factory to recreate the `OfferRandomizer` when options change — this is a larger change and would require modifying how `IOfferRandomizer` is registered.

- Availability and quantities:

  - Most of the time (~80%) the supplier can fulfill the entire requested amount.
  - Occasionally (~10%) the supplier offers a reduced quantity (randomly reduced by 1%–30%, but at least 1).
  - Rarely (~10%) the product is unavailable and `OfferedAmount` becomes `0` and `IsAvailable` is `false`.

- Delivery duration:

  - Common cases are 2–3 days (~70%).
  - Less common cases are 4+ days where the randomizer adds additional days.

- Transportation cost:
  - A fixed transportation cost (configured in `OfferRandomizer`) is included on every `OfferResponse`.

Randomness provider

- The random behavior is abstracted behind an `IRandomProvider` interface so the source of randomness can be swapped.
- By default the application registers a `SecureRandomProvider` which uses the platform cryptographic RNG to produce less-predictable values at runtime. This makes offer outcomes harder to predict across runs compared to a single, time-seeded `System.Random`.
- A seeded `SystemRandomProvider` implementation still exists and can be used when deterministic, repeatable sequences are needed (for example in unit tests).

The `OfferRandomizer` depends on an `IRandomProvider` abstraction (production binding uses a `SystemRandomProvider`), making the random behavior replaceable for deterministic tests.

## Database Configuration

The service uses Entity Framework Core with SQL Server for persisting orders and managing supplier data.

### Connection String

The database connection string is configured in `appsettings.json` under `ConnectionStrings:DefaultDatabase`:

```json
{
  "ConnectionStrings": {
    "DefaultDatabase": "Data Source=...;Initial Catalog=PurchasingDB;..."
  }
}
```

### Database Initialization

The database is initialized with supplier data automatically through EF Core migrations. To create/update the database:

```bash
dotnet ef database update
```

### Order Management Endpoints

- `POST /Order/placeOrder` — create and persist a new order
  - Input: `Order` object with `RequestId`, `SupplierId`, `Date`, and `OrderDetails` array
  - Output: confirmation with order total
  - The order is saved to the database

- `GET /Order/getOrders` — retrieve all orders with denormalized view
  - Output: Array of orders with columns:
    - `Id` — order unique identifier (GUID)
    - `RequestId` — correlation identifier
    - `Date` — order date
    - `OrderTotal` — calculated sum of all order details (price × quantity)
    - `SupplierName` — company name of the supplier

### Data Model

- **Suppliers** — stored in database with their contact information
- **SupplierProducts** — many-to-many relationship between suppliers and their products
- **Orders** — order headers with supplier reference
- **OrderDetails** — line items for each order (product name, price, quantity)
